using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace RecordInterfaces.SourceGenerators;

using NodeDescriptor = (
    RecordDeclarationSyntax Node,
    bool RecordInterfaceAttributeFound);

using PropertyDescriptor = (
    string Type,
    string Name,
    bool IsNullable);

using RecordInterfaceExtension = (
    string RecordTypeName,
    string ExtensionsTypeName,
    string Code);

[Generator]
public sealed class ExtendedRecordInterfaceSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context
           .SyntaxProvider
           .CreateSyntaxProvider(
                (node, _) => node is RecordDeclarationSyntax,
                (ctx, _) => GetRecordDeclarationsForSourceGen(ctx))
           .Where(x => x.RecordInterfaceAttributeFound)
           .Select((x, _) => x.Node);

        var source = context
           .CompilationProvider
           .Combine(provider.Collect());

        context.RegisterSourceOutput(
                source,
                (ctx, src) => GenerateCode(ctx, src.Left, src.Right));
    }

    private static NodeDescriptor GetRecordDeclarationsForSourceGen(GeneratorSyntaxContext context)
    {
        var recordDeclarationSyntax = (RecordDeclarationSyntax) context.Node;

        var attributesSyntax = recordDeclarationSyntax
           .AttributeLists
           .SelectMany(x => x.Attributes);


        foreach (var attributeSyntax in attributesSyntax)
        {
            var maybeAttributeSymbol = context
               .SemanticModel
               .GetSymbolInfo(attributeSyntax)
               .Symbol;

            if (maybeAttributeSymbol is not IMethodSymbol attributeSymbol)
                continue;

            var attributeName = attributeSymbol
               .ContainingType
               .ToDisplayString();

            // TODO: fix, typeof() does not work
            if (attributeName == "RecordInterfaces.Abstractions.ExtendedRecordInterfaceImplementationAttribute")
                return (recordDeclarationSyntax, true);
        }

        return (recordDeclarationSyntax, false);
    }

    private static void GenerateCode(
        SourceProductionContext context,
        Compilation compilation,
        ImmutableArray<RecordDeclarationSyntax> recordDeclarationSyntaxes)
    {
        var groupedRecords = recordDeclarationSyntaxes
           .SelectMany(r =>
                GetExtendedRecordInterfaceNames(r, compilation)
                   .Select(i => (Record: r, Interface: i)))
           .GroupBy(x => x.Interface)
           .Select(x => (
                Interface: x.Key,
                Records: x.Select(y => y.Record).ToImmutableArray()))
           .ToList();

        foreach (var (interfaceDeclarationSyntax, records) in groupedRecords)
        {
            var recordExtensionsCode = CreateRecordExtensionsCode(
                interfaceDeclarationSyntax,
                records,
                compilation);

            var interfaceExtensionCode = CreateWithInterfaceExtensionCode(
                interfaceDeclarationSyntax,
                recordExtensionsCode,
                compilation);

            var interfaceNamespace = GetNamespace(interfaceDeclarationSyntax);
            var recordNamespaces = string.Join("\n", records
               .Select(GetNamespace)
               .Select(x => $"using {x};")
               .Distinct());

            var recordExtensions = string.Join("\n", recordExtensionsCode.Select(x => x.Code));

            var code =
                $"""
                  // <auto-generated/>
                  
                  #nullable enable
                  
                  using Microsoft.CodeAnalysis;
                  using System.Runtime.CompilerServices;
                  
                  {recordNamespaces}
                  
                  namespace {interfaceNamespace};
                  
                  {recordExtensions}
                  
                  {interfaceExtensionCode}

                  """;

            var @interface = interfaceDeclarationSyntax.Identifier.Text;
            context.AddSource($"{@interface}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }

    private static ImmutableArray<InterfaceDeclarationSyntax> GetExtendedRecordInterfaceNames(
        RecordDeclarationSyntax recordDeclarationSyntax,
        Compilation compilation)
    {
        var baseList = recordDeclarationSyntax.BaseList;

        if (baseList is null)
            return ImmutableArray<InterfaceDeclarationSyntax>.Empty;

        var root = recordDeclarationSyntax.SyntaxTree.GetRoot();
        var rootSemanticModel = compilation.GetSemanticModel(root.SyntaxTree);

        List<InterfaceDeclarationSyntax> recordInterfaceNames = [];

        foreach (var interfaceDeclaration in root.DescendantNodes().OfType<InterfaceDeclarationSyntax>())
        {
            if (rootSemanticModel.GetDeclaredSymbol(interfaceDeclaration) is not INamedTypeSymbol interfaceSymbol)
                continue;

            var isRecordInterface = interfaceSymbol
               .GetAttributes()
               .Any(x => x.AttributeClass!.ToDisplayString() ==
                         "RecordInterfaces.Abstractions.ExtendedRecordInterfaceAttribute");

            if (!isRecordInterface)
                continue;

            recordInterfaceNames.Add(interfaceDeclaration);
        }

        return recordInterfaceNames.ToImmutableArray();
    }

    private static ImmutableArray<RecordInterfaceExtension> CreateRecordExtensionsCode(
        InterfaceDeclarationSyntax interfaceDeclarationSyntax,
        in ImmutableArray<RecordDeclarationSyntax> recordDeclarationSyntaxes,
        Compilation compilation)
    {
        StringBuilder sb = new();
        List<RecordInterfaceExtension> extensions = [];

        foreach (var recordDeclarationSyntax in recordDeclarationSyntaxes)
        {
            var record = recordDeclarationSyntax.Identifier.Text;
            var @interface = interfaceDeclarationSyntax.Identifier.Text;
            var properties = GetTypeProperties(interfaceDeclarationSyntax, compilation);

            var parameters = CreateOptionalParametersCode(properties);
            sb.Clear();

            var unsafeAccessors = CreateUnsafeAccessorsCode(properties, record, sb);
            sb.Clear();

            var setters = CreateSettersCode(properties, sb);
            sb.Clear();

            var extensionsClassName = $"{record}Extensions";

            var code =
                $$"""
                  // <auto-generated/>
                  
                  file class {{extensionsClassName}}
                  {
                      public static {{@interface}} With({{@interface}} record, {{parameters}})
                      {
                          var @this = ({{record}}) record;
                          
                          [UnsafeAccessor(UnsafeAccessorKind.Method, Name = "<Clone>$")]
                          static extern {{record}} Clone({{record}} @this);
                          
                  {{unsafeAccessors}}
                      
                          var clone = Clone(@this);
                          
                  {{setters}}
                      
                          return clone;
                      }
                  }
                  """;

            extensions.Add((record, extensionsClassName, code));
        }

        return extensions.ToImmutableArray();
    }

    private static ImmutableArray<PropertyDescriptor> GetTypeProperties(
        SyntaxNode syntax,
        Compilation compilation)
    {
        var propertyDeclarations = syntax
           .DescendantNodes()
           .OfType<PropertyDeclarationSyntax>()
           .ToImmutableArray();

        var interfaceSemanticModel = compilation.GetSemanticModel(syntax.SyntaxTree);
        List<PropertyDescriptor> propertyDescriptors = [];

        foreach (var propertyDeclaration in propertyDeclarations)
        {
            if (interfaceSemanticModel.GetDeclaredSymbol(propertyDeclaration) is not IPropertySymbol property)
                continue;

            propertyDescriptors.Add((
                property.Type.Name,
                property.Name,
                property.Type.NullableAnnotation == NullableAnnotation.Annotated));
        }

        return propertyDescriptors.ToImmutableArray();
    }

    private static string CreateOptionalParametersCode(
        in ImmutableArray<PropertyDescriptor> properties)
    {
        StringBuilder sb = new();

        foreach (var (type, name, isNullable) in properties)
        {
            sb.Append("\n        ");
            sb.Append("Optional");
            sb.Append("<");
            sb.Append(type);

            if (isNullable)
                sb.Append("?");

            sb.Append('>');
            sb.Append(' ');
            sb.Append(char.ToLower(name[0]) + name[1..]);
            sb.Append(" = default,");
        }

        return sb.ToString(0, sb.Length - 1);
    }

    private static string CreateUnsafeAccessorsCode(
        in ImmutableArray<PropertyDescriptor> properties,
        string record,
        StringBuilder sb)
    {
        foreach ((string type, string name, _) in properties)
        {
            sb.Append("        ");
            sb.Append($"[UnsafeAccessor(UnsafeAccessorKind.Method, Name = \"set_{name}\")]\n");
            sb.Append("        ");
            sb.Append($"static extern void Set{name}({record} @this, {type} value);\n\n");
        }

        return sb.ToString(0, sb.Length - 2);
    }

    private static string CreateSettersCode(
        in ImmutableArray<PropertyDescriptor> properties,
        StringBuilder sb)
    {
        foreach ((string _, string name, _) in properties)
        {
            var parameterName = char.ToLower(name[0]) + name[1..];

            var setter =
                $"""
                          if ({parameterName}.HasValue)
                              Set{name}(clone, {parameterName}.Value);

                 """;

            sb.Append(setter);
        }

        return sb.ToString(0, sb.Length - 1);
    }

    private static string CreateWithInterfaceExtensionCode(
        InterfaceDeclarationSyntax interfaceDeclarationSyntax,
        in ImmutableArray<RecordInterfaceExtension> recordDeclarationSyntaxes,
        Compilation compilation)
    {
        StringBuilder sb = new();

        var properties = GetTypeProperties(interfaceDeclarationSyntax, compilation);

        var unsafeExtensionAccessors = CreateUnsafeExtensionAccessorsCode(
            interfaceDeclarationSyntax,
            recordDeclarationSyntaxes,
            properties,
            sb);

        sb.Clear();

        var typeMatching = CreateTypeMatchingCode(
            recordDeclarationSyntaxes,
            properties,
            sb);

        sb.Clear();

        var @interface = interfaceDeclarationSyntax.Identifier.Text;

        var propertiesWithThis = properties
           .ToImmutableArray();

        var parameters = CreateOptionalParametersCode(propertiesWithThis);
        sb.Clear();

        var code =
            $$"""
              public static class {{@interface}}Extensions
              {
                  public static {{@interface}} With(this {{@interface}} @this, {{parameters}})
                  {
              {{unsafeExtensionAccessors}}
                  
                      return @this switch
                      {
              {{typeMatching}}
                      };
                  }
              }
              """;

        return code;
    }

    private static string CreateUnsafeExtensionAccessorsCode(
        InterfaceDeclarationSyntax interfaceDeclarationSyntax,
        in ImmutableArray<RecordInterfaceExtension> recordDeclarationSyntaxes,
        in ImmutableArray<PropertyDescriptor> interfaceProperties,
        StringBuilder sb)
    {
        var @interface = interfaceDeclarationSyntax.Identifier.Text;

        var properties = interfaceProperties
           .ToImmutableArray();

        var parameters = CreateOptionalParametersCode(properties);

        foreach (var (recordTypeName, extensionsTypeName, _) in recordDeclarationSyntaxes)
        {
            var code =
                $"""
                     [UnsafeAccessor(UnsafeAccessorKind.StaticMethod, Name = "With")]
                     static extern {@interface} Invoke{recordTypeName}With({extensionsTypeName} extensions, {@interface} record, {parameters});

                 """;

            sb.Append(code);
        }

        return sb.ToString(0, sb.Length - 1);
    }

    private static string CreateTypeMatchingCode(
        in ImmutableArray<RecordInterfaceExtension> recordDeclarationSyntaxes,
        in ImmutableArray<PropertyDescriptor> interfaceProperties,
        StringBuilder sb)
    {
        var parameterNames = interfaceProperties
           .Select(x => x.Name)
           .Select(x => char.ToLower(x[0]) + x[1..])
           .ToImmutableArray();

        var interfaceParams = string.Join(", ", parameterNames);

        foreach (var (recordTypeName, _, _) in recordDeclarationSyntaxes)
        {
            sb.Append("            ");
            sb.Append(recordTypeName);
            sb.Append(" => ");
            sb.Append($"Invoke{recordTypeName}With(null, @this, {interfaceParams}),\n");
        }

        sb.Append("            ");
        sb.Append("_  => throw new NotImplementedException($\"Type {@this.GetType().Name} is not a record type\")");

        return sb.ToString();
    }

    // determine the namespace the class/enum/struct is declared in, if any
    private static string GetNamespace(SyntaxNode syntax)
    {
        // If we don't have a namespace at all we'll return an empty string
        // This accounts for the "default namespace" case
        string nameSpace = string.Empty;

        // Get the containing syntax node for the type declaration
        // (could be a nested type, for example)
        var potentialNamespaceParent = syntax.Parent;

        // Keep moving "out" of nested classes etc. until we get to a namespace
        // or until we run out of parents
        while (potentialNamespaceParent != null &&
               potentialNamespaceParent is not NamespaceDeclarationSyntax
            && potentialNamespaceParent is not FileScopedNamespaceDeclarationSyntax)
        {
            potentialNamespaceParent = potentialNamespaceParent.Parent;
        }

        // Build up the final namespace by looping until we no longer have a namespace declaration
        if (potentialNamespaceParent is BaseNamespaceDeclarationSyntax namespaceParent)
        {
            // We have a namespace. Use that as the type
            nameSpace = namespaceParent.Name.ToString();

            // Keep moving "out" of the namespace declarations until we
            // run out of nested namespace declarations
            while (true)
            {
                if (namespaceParent.Parent is not NamespaceDeclarationSyntax parent)
                {
                    break;
                }

                // Add the outer namespace as a prefix to the final namespace
                nameSpace = $"{namespaceParent.Name}.{nameSpace}";
                namespaceParent = parent;
            }
        }

        // return the final namespace
        return nameSpace;
    }
}
